\chapter[Sample Course]{Sample Course}
\label{ch:sample_course}
In order to present the functionality and usage of web application, a sample course was created. Its exercises include all the exercises types and agile programming methods. The following section will lead through the content of the course.

    \section{Sample course overview}
    There are three lessons in the course, each represents an iteration of the work on the program. Every lesson contains exercises, which lead through the work on the project. The course is designed in such a way, so the user would learn agile programming methods and apply his skills while working on the project. Most of the exercises would cover multiple skills, like test-driven development, unit testing, refactoring and working with legacy code.
    
    Section \href{subsec:legacy-program}{\textit{Legacy program overview}} gives more information about the program, which is worked on during the course. Further sections \textit{Lesson 1 to 3} describes lessons content, purpose, and which agile programming methodologies do they introduce.
    
    
        \subsection{Legacy program overview}
        \label{subsec:legacy-program}
        The student would work on an interactive Reversi game, based on a legacy program. It is a console application for two players. Each Reversi piece has a black side and a white side. The state of the game is read from configuration files, which have the following structure: first row has "B" (black) or "W" (white), which means the player on turn; the second row contains positions of black pieces; and the third row contains positions of white pieces. When the game starts, program asks a player on turn to enter piece position to move on. The game ends when player on turn has no pieces to move on. The one, who has more pieces on the board, wins the game.
    
    
        \subsection{Lesson 1: Debugging a legacy program}
        The first lesson is called \textit{Debugging a legacy program} and it contains three exercises, which step by step lead through looking for mistakes and fixing them.
            
        As soon as the programmer does not know how legacy program works, even if he is the author, it becomes more difficult to fix mistakes and not produce more. And using tests becomes more crucial than usually. The purpose of the following exercises is to show how testing is useful for fixing program correctly and efficiently.
        
            \subsubsection{Exercise 1: Intro}
            The first exercise is introductory. It contains no assignments, but acquaints the user with general information about the course, its lessons, exercises and the legacy program.
            
            \subsubsection{Exercise 2: Finding the Bugs in Legacy Program}
            Work with legacy code starts from the second exercise. The user would get program, which contains three mistakes. As soon as this exercise is of type \textit{Black Box with Files}, the user would be provided only with development editors for tests and files. He would not be able to see or change source code of the program.
            
            Exercise is designed in such a way, so the user would practice test-driven development. The user would need to write tests to find the mistakes. On submit, the user would get a feedback, telling how much errors did he reveal and their total number.
            
            The mistakes relate to marginal cases and incorrect user inputs. Original program works incorrectly on such an inputs: move on piece, which is not empty; move on not adjacent piece, what violates the rules; and move out of the bounds of the board.
            
            \subsubsection{Exercise 3: Debugging the Legacy Program}
            When user reveals mistakes in the previous exercise, these mistakes would be corrected in this one. It is recommended to use tests, which were submitted in the previous exercise, and web applications provides such a feature to make work with legacy code more convenient. This exercise is interactive, so user would solve it with changing the program files, running the modified program and get feedback on his solution.
            
        
        \subsection{Lesson 2: Adding new features to the legacy program}
        The second lesson is devoted to the most often kind of work with legacy code, which is adding a new feature. Adding new functionality may be as risky as fixing the mistakes, so proper testing is important too. The aim of this lesson is to show how unit testing can be helpful for making sure, that program remains functional. Also this lesson would introduce of safe and efficient methods of changing legacy code.
        
            \subsubsection{Exercise 1: Board Size}
            In this exercise the student should add a new feature, and to use tests to be sure that the program is solvable. The code uses magic constants, which represent a board size. The student should use a variable instead. When refactored, a new feature can be implemented with the use of sprout method. The configuration files contain one more line for configuring a board size, sprout methods would read them a store size to the variable.
        
            \subsubsection{Exercise 2: Show Hints}
            This exercise is aimed to acquaint with one of the techniques of safe legacy code modifying. Student should add a new feature of showing hints, and a new code should be isolated form the old one. Sprout technique should be used, so old code would not be modified, and it would be possible to test a new feature.
        
        \subsection{Lesson 3: Refactoring the legacy program}
        The last lesson is devoted to the most efficient way to tidy code and make it easier to aim three factors of code quality and cleanliness: readability, maintainability and extensibility. Refactoring should be done in the end and no other code changes should be done at the same time. Because of this, this iteration of programming is done within the last lesson of the course. Each of the following exercises is devoted to one of the techniques of refactoring and leads step by step through them. These techniques will be practices on the legacy code from previous lessons, as soon it is a good example of program with lack of refactoring, and it becomes a good proof of necessity of it. Exercise titles refer to related chapters of the book \textit{``Clean Code: A Handbook of Agile Software Craftsmanship''} by Robert C. Martin. Also exercises contain citations from it, which describe the reason and idea behind the used techniques in the best way.
        
            \subsubsection{Exercise 1: Constants versus Enums}
            This step of refactoring is aimed to make the code more readable. Original legacy code uses integers to represent cells to tell if a black, white or no piece is placed on it. The task is to replace these repetitive numbers with constant variables. In this case it is more reasonable to prefer \textit{enum} with name \textit{Player} rather than \textit{constant}, as soon as its meaning cannon be lost, because they belong to an enumeration that is named \cite[Constants versus Enums]{clean_code}.
            
            \subsubsection{Exercise 2: No Duplication}
            The next step of refactoring is described as `\textit{the primary enemy of a well-designed system}' by Robert C. Martin, and he explains why: ``\textit{It represents additional work, additional risk, and additional unnecessary complexity}\cite[No Duplication]{clean_code}.''
            
            Source code from the exercise contains repetitive code, and the task is to eliminate such a duplicitous with extracting new functions and use them. The most noticeable advantage of this change is that instead making changes in every occurrence of such a code, it is enough to change it once in one place.
            
            \subsubsection{Exercise 3: Do One Thing}
            The next exercise introduces an important principle of programming, which is applied to programming entities on many levels, e.g. lines of code, functions, classes, and even refactoring itself. The legacy code contains several cases of violating this principle\cite[Do One Thing]{clean_code}.
            
            The aim of the exercise is to extract new functions from the others, which do more then `one thing'. As a result, work with code becomes more efficient. It becomes possible to test application on more levels, to use methods of changing legacy code is needed, and to understand what function does at one glance.
            
            \subsubsection{Exercise 4: One Level of Abstraction per Function}
            When the core steps of refactoring are completed, this exercise introduces often neglected step of refactoring, which improves code readability significantly.
            
            This exercise suggests the same solution of extracting methods as the previous ones. As a result of this separation, it becomes clear which lines of code express an essential concept or a detail \cite[One Level of Abstraction per Function]{clean_code}.
            
            \subsubsection{Exercise 5: Small!}
            When a function is too big to fit into the screen, it makes it clear, that it should be refactored \cite[Small!]{clean_code}. Previous refactoring steps lead not only to the mentioned benefits, but also reduce size of the functions. Most of them used extraction of one functions from another to aim the goals, but this exercise suggests one more approach.
            
            The task is to change the structure of storing values, which represent the number of black and white pieces on the board. When using a map instead of two integers, one of the function significantly reduces, and readability is not only maintained, but also improved.
            
            \subsubsection{Exercise 6: Error Handling I \& Exercise 7: Error Handling II}
            The last two exercises conclude the lesson with leading through handling the errors. They belong to the lesson on refactoring, as soon as it is important to write clean code to handle errors.
            
            There are two kinds of errors, so work on them is separated into two exercises. Legacy code uses a harmful practice of printing messages to console and returning \textit{void}, when any error occurs. It leads to unexpected program behaviour, which may be difficult to reveal, repeat and correct. The exercises suggest use of custom exceptions to catch errors efficiently.
